/*
 * Generated by Claude version 4 chat.
 * May contain hallucinations,
 * Bit of an experiment tech spike to test LLM AI generation of something:
 *   * Low risk - types.
 *   * Tedious that a computer an probably do better.
 *
 *  With some fixes by me, a human.
 */

// Met Office DataHub Daily Weather Forecast GeoJSON TypeScript Types

import type { FeatureCollection, Feature, Point } from 'geojson';

/**
 * Hourly weather data for a specific time
 */
interface HourlyWeatherData {
  time: string; // ISO 8601 datetime string (YYYY-MM-DDTHH:mm:ssZ)

  // Temperature parameters
  screenTemperature: number; // degrees Celsius
  maxScreenAirTemp: number; // degrees Celsius (max over previous hour)
  minScreenAirTemp: number; // degrees Celsius (min over previous hour)
  screenDewPointTemperature: number; // degrees Celsius
  feelsLikeTemperature: number; // degrees Celsius

  // Wind parameters
  windSpeed10m: number; // m/s
  windDirectionFrom10m: number; // degrees
  windGustSpeed10m: number; // m/s
  max10mWindGust: number; // m/s (max over previous hour)

  // Atmospheric parameters
  visibility: number; // metres
  screenRelativeHumidity: number; // percentage
  mslp: number; // pascals (Mean Sea Level Pressure)
  uvIndex: number; // dimensionless

  // Weather condition
  significantWeatherCode: number; // Met Office weather code

  // Precipitation parameters
  precipitationRate: number; // mm/h
  totalPrecipAmount: number; // mm (total over previous hour)
  totalSnowAmount: number; // mm (total over previous hour)
  probOfPrecipitation: number; // percentage
}

/**
 * Properties of an hourly weather forecast feature
 */
interface HourlyWeatherForecastProperties {
  // Distance from requested point to actual forecast point
  requestPointDistance: number; // metres

  // Model run information
  modelRunDate: string; // ISO 8601 datetime string

  // Time series data - array of hourly forecasts
  timeSeries: HourlyWeatherData[];
}

/**
 * Individual feature in the hourly GeoJSON FeatureCollection
 */
type HourlyWeatherForecastFeature = Feature<
  Point,
  HourlyWeatherForecastProperties
>;

/**
 * Main GeoJSON response structure from Met Office DataHub hourly forecast
 */
interface MetOfficeHourlyForecastGeoJSON
  extends FeatureCollection<Point, HourlyWeatherForecastProperties> {
  // Parameter metadata describing all available parameters
  parameters?: ParameterMetadata[];
}

/**
 * Daily weather data for a specific date
 */
interface DailyWeatherData {
  time: string; // ISO 8601 date string (YYYY-MM-DDTHH:mm:ssZ)

  // Wind parameters
  midday10MWindSpeed: number; // m/s
  midnight10MWindSpeed: number; // m/s
  midday10MWindDirection: number; // degrees
  midnight10MWindDirection: number; // degrees
  midday10MWindGust: number; // m/s
  midnight10MWindGust: number; // m/s

  // Visibility parameters
  middayVisibility: number; // metres
  midnightVisibility: number; // metres

  // Humidity parameters
  middayRelativeHumidity: number; // percentage
  midnightRelativeHumidity: number; // percentage

  // Pressure parameters
  middayMslp: number; // pascals
  midnightMslp: number; // pascals

  // UV parameters
  maxUvIndex: number; // dimensionless

  // Weather codes
  daySignificantWeatherCode: number; // Met Office weather code
  nightSignificantWeatherCode: number; // Met Office weather code

  // Temperature parameters
  dayMaxScreenTemperature: number; // degrees Celsius
  nightMinScreenTemperature: number; // degrees Celsius
  dayUpperBoundMaxTemp: number; // degrees Celsius
  nightUpperBoundMinTemp: number; // degrees Celsius
  dayLowerBoundMaxTemp: number; // degrees Celsius
  nightLowerBoundMinTemp: number; // degrees Celsius

  // Feels like temperature parameters
  dayMaxFeelsLikeTemp: number; // degrees Celsius
  nightMinFeelsLikeTemp: number; // degrees Celsius
  dayUpperBoundMaxFeelsLikeTemp: number; // degrees Celsius
  nightUpperBoundMinFeelsLikeTemp: number; // degrees Celsius
  dayLowerBoundMaxFeelsLikeTemp: number; // degrees Celsius
  nightLowerBoundMinFeelsLikeTemp: number; // degrees Celsius

  // Precipitation probability parameters
  dayProbabilityOfPrecipitation: number; // percentage
  nightProbabilityOfPrecipitation: number; // percentage
  dayProbabilityOfSnow: number; // percentage
  nightProbabilityOfSnow: number; // percentage
  dayProbabilityOfHeavySnow: number; // percentage
  nightProbabilityOfHeavySnow: number; // percentage
  dayProbabilityOfRain: number; // percentage
  nightProbabilityOfRain: number; // percentage
  dayProbabilityOfHeavyRain: number; // percentage
  nightProbabilityOfHeavyRain: number; // percentage
  dayProbabilityOfHail: number; // percentage
  nightProbabilityOfHail: number; // percentage
  dayProbabilityOfSferics: number; // percentage
  nightProbabilityOfSferics: number; // percentage
}

/**
 * Parameter metadata structure
 */
interface ParameterUnit {
  label: string;
  symbol: {
    value: string;
    type: string;
  };
}

interface ParameterMetadata {
  [key: string]: {
    type: 'Parameter';
    description: string;
    unit: ParameterUnit;
  };
}

/**
 * Properties of a daily weather forecast feature
 */
interface DailyWeatherForecastProperties {
  // Distance from requested point to actual forecast point
  requestPointDistance: number; // metres

  // Model run information
  modelRunDate: string; // ISO 8601 datetime string

  // Time series data - array of daily forecasts
  timeSeries: DailyWeatherData[];
}

/**
 * Individual feature in the GeoJSON FeatureCollection
 */
type DailyWeatherForecastFeature = Feature<
  Point,
  DailyWeatherForecastProperties
>;

/**
 * Main GeoJSON response structure from Met Office DataHub daily forecast
 */
interface MetOfficeDailyForecastGeoJSON
  extends FeatureCollection<Point, DailyWeatherForecastProperties> {
  // Parameter metadata describing all available parameters
  parameters?: ParameterMetadata[];
}

/**
 * API response wrapper
 */
interface MetOfficeApiResponse {
  data?: MetOfficeDailyForecastGeoJSON;
  status?: string;
  message?: string;
  timestamp?: string;
}

/**
 * Weather codes used by Met Office (significant weather codes)
 */
enum MetOfficeWeatherCode {
  ClearNight = 0,
  SunnyDay = 1,
  PartlyCloudyNight = 2,
  PartlyCloudyDay = 3,
  NotUsed = 4, // Not used
  Mist = 5,
  Fog = 6,
  CloudyDay = 7,
  OvercastDay = 8,
  LightRainShowerNight = 9,
  LightRainShowerDay = 10,
  Drizzle = 11,
  LightRain = 12,
  HeavyRainShowerNight = 13,
  HeavyRainShowerDay = 14,
  HeavyRain = 15,
  SleetShowerNight = 16,
  SleetShowerDay = 17,
  Sleet = 18,
  HailShowerNight = 19,
  HailShowerDay = 20,
  Hail = 21,
  LightSnowShowerNight = 22,
  LightSnowShowerDay = 23,
  LightSnow = 24,
  HeavySnowShowerNight = 25,
  HeavySnowShowerDay = 26,
  HeavySnow = 27,
  ThunderShowerNight = 28,
  ThunderShowerDay = 29,
  Thunder = 30,
}

/**
 * Type guard to check if response is valid Met Office hourly forecast GeoJSON
 */
function isMetOfficeHourlyForecastGeoJSON(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  data: any
): data is MetOfficeHourlyForecastGeoJSON {
  return (
    data &&
    typeof data === 'object' &&
    data.type === 'FeatureCollection' &&
    Array.isArray(data.features) &&
    data.features.every(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (feature: any) =>
        feature.type === 'Feature' &&
        feature.geometry &&
        feature.geometry.type === 'Point' &&
        Array.isArray(feature.geometry.coordinates) &&
        feature.geometry.coordinates.length >= 2 &&
        feature.properties &&
        Array.isArray(feature.properties.timeSeries) &&
        feature.properties.timeSeries.every(
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (hour: any) =>
            hour && typeof hour === 'object' && typeof hour.time === 'string'
        )
    )
  );
}

/**
 * Get weather data for a specific hour
 */
function getHourlyWeatherForTime(
  forecast: MetOfficeHourlyForecastGeoJSON,
  dateTime: string | Date,
  featureIndex: number = 0
): HourlyWeatherData | null {
  const feature = forecast.features[featureIndex];
  if (!feature) return null;

  const targetDateTime =
    typeof dateTime === 'string' ? dateTime : dateTime.toISOString();

  return (
    feature.properties.timeSeries.find(
      (hour) => hour.time === targetDateTime
    ) || null
  );
}

/**
 * Get current/latest hourly weather data
 */
function getCurrentHourlyWeather(
  forecast: MetOfficeHourlyForecastGeoJSON,
  featureIndex: number = 0
): HourlyWeatherData | null {
  const feature = forecast.features[featureIndex];
  if (!feature || feature.properties.timeSeries.length === 0) return null;

  const now = new Date();
  const currentHour = new Date(
    now.getFullYear(),
    now.getMonth(),
    now.getDate(),
    now.getHours()
  ).toISOString();

  // Try to find current hour's data first
  const currentData = feature.properties.timeSeries.find(
    (hour) => hour.time.startsWith(currentHour.substring(0, 13)) // Match YYYY-MM-DDTHH
  );

  if (currentData) return currentData;

  // Otherwise return the first available hour
  return feature.properties.timeSeries[0];
}

/**
 * Get hourly data for a specific date
 */
function getHourlyWeatherForDate(
  forecast: MetOfficeHourlyForecastGeoJSON,
  date: string | Date,
  featureIndex: number = 0
): HourlyWeatherData[] {
  const feature = forecast.features[featureIndex];
  if (!feature) return [];

  const targetDate =
    typeof date === 'string' ? date : date.toISOString().split('T')[0];

  return feature.properties.timeSeries.filter((hour) =>
    hour.time.startsWith(targetDate)
  );
}

/**
 * Get all available hours in the forecast
 */
function getAvailableHours(
  forecast: MetOfficeHourlyForecastGeoJSON,
  featureIndex: number = 0
): string[] {
  const feature = forecast.features[featureIndex];
  if (!feature) return [];

  return feature.properties.timeSeries.map((hour) => hour.time);
}
/**
 * Type guard to check if response is valid Met Office daily forecast GeoJSON
 */
function isMetOfficeDailyForecastGeoJSON(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  data: any
): data is MetOfficeDailyForecastGeoJSON {
  return (
    data &&
    typeof data === 'object' &&
    data.type === 'FeatureCollection' &&
    Array.isArray(data.features) &&
    data.features.every(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (feature: any) =>
        feature.type === 'Feature' &&
        feature.geometry &&
        feature.geometry.type === 'Point' &&
        Array.isArray(feature.geometry.coordinates) &&
        feature.geometry.coordinates.length >= 2 &&
        feature.properties &&
        Array.isArray(feature.properties.timeSeries) &&
        feature.properties.timeSeries.every(
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (day: any) =>
            day && typeof day === 'object' && typeof day.time === 'string'
        )
    )
  );
}

/**
 * Get weather data for a specific date
 */
function getWeatherForDate(
  forecast: MetOfficeDailyForecastGeoJSON,
  date: string | Date,
  featureIndex: number = 0
): DailyWeatherData | null {
  const feature = forecast.features[featureIndex];
  if (!feature) return null;

  const targetDate =
    typeof date === 'string' ? date : date.toISOString().split('T')[0];

  return (
    feature.properties.timeSeries.find((day) =>
      day.time.startsWith(targetDate)
    ) || null
  );
}

/**
 * Get the latest/current weather data
 */
function getCurrentWeather(
  forecast: MetOfficeDailyForecastGeoJSON,
  featureIndex: number = 0
): DailyWeatherData | null {
  const feature = forecast.features[featureIndex];
  if (!feature || feature.properties.timeSeries.length === 0) return null;

  const now = new Date();
  const today = now.toISOString().split('T')[0];

  // Try to find today's data first
  const todayData = feature.properties.timeSeries.find((day) =>
    day.time.startsWith(today)
  );

  if (todayData) return todayData;

  // Otherwise return the first available day
  return feature.properties.timeSeries[0];
}

/**
 * Get all dates available in the forecast
 */
function getAvailableDates(
  forecast: MetOfficeDailyForecastGeoJSON,
  featureIndex: number = 0
): string[] {
  const feature = forecast.features[featureIndex];
  if (!feature) return [];

  return feature.properties.timeSeries.map((day) => day.time.split('T')[0]);
}

/**
 * Extract parameter metadata by parameter name
 */
function getParameterMetadata(
  forecast: MetOfficeDailyForecastGeoJSON,
  parameterName: keyof DailyWeatherData
): ParameterMetadata | null {
  if (!forecast.parameters) return null;

  return (
    forecast.parameters.find((param) =>
      Object.prototype.hasOwnProperty.call(param, parameterName)
    ) || null
  );
}

/**
 * Temperature range helper
 */
interface TemperatureRange {
  max: number;
  min: number;
  maxUpperBound?: number;
  maxLowerBound?: number;
  minUpperBound?: number;
  minLowerBound?: number;
}

/**
 * Get temperature range for a day
 */
function getTemperatureRange(day: DailyWeatherData): TemperatureRange | null {
  if (
    day.dayMaxScreenTemperature === undefined ||
    day.nightMinScreenTemperature === undefined
  ) {
    return null;
  }

  return {
    max: day.dayMaxScreenTemperature,
    min: day.nightMinScreenTemperature,
    maxUpperBound: day.dayUpperBoundMaxTemp,
    maxLowerBound: day.dayLowerBoundMaxTemp,
    minUpperBound: day.nightUpperBoundMinTemp,
    minLowerBound: day.nightLowerBoundMinTemp,
  };
}

/**
 * Get temperature trend over time (hourly data)
 */
interface TemperatureTrend {
  timestamps: string[];
  temperatures: number[];
  feelsLike: number[];
  min: number;
  max: number;
  average: number;
}

function getHourlyTemperatureTrend(
  forecast: MetOfficeHourlyForecastGeoJSON,
  featureIndex: number = 0
): TemperatureTrend | null {
  const feature = forecast.features[featureIndex];
  if (!feature) return null;

  const validHours = feature.properties.timeSeries.filter(
    (hour) =>
      hour.screenTemperature !== undefined &&
      hour.feelsLikeTemperature !== undefined
  );

  if (validHours.length === 0) return null;

  const temperatures = validHours.map((hour) => hour.screenTemperature!);
  const feelsLike = validHours.map((hour) => hour.feelsLikeTemperature!);

  return {
    timestamps: validHours.map((hour) => hour.time),
    temperatures,
    feelsLike,
    min: Math.min(...temperatures),
    max: Math.max(...temperatures),
    average:
      temperatures.reduce((sum, temp) => sum + temp, 0) / temperatures.length,
  };
}

/**
 * Get precipitation forecast (hourly data)
 */
interface PrecipitationForecast {
  timestamps: string[];
  rates: number[];
  amounts: number[];
  probabilities: number[];
  snowAmounts: number[];
  totalAmount: number;
  peakRate: number;
  averageProbability: number;
}

function getHourlyPrecipitationForecast(
  forecast: MetOfficeHourlyForecastGeoJSON,
  featureIndex: number = 0
): PrecipitationForecast | null {
  const feature = forecast.features[featureIndex];
  if (!feature) return null;

  const validHours = feature.properties.timeSeries.filter(
    (hour) =>
      hour.precipitationRate !== undefined ||
      hour.totalPrecipAmount !== undefined ||
      hour.probOfPrecipitation !== undefined
  );

  if (validHours.length === 0) return null;

  const rates = validHours.map((hour) => hour.precipitationRate ?? 0);
  const amounts = validHours.map((hour) => hour.totalPrecipAmount ?? 0);
  const probabilities = validHours.map((hour) => hour.probOfPrecipitation ?? 0);
  const snowAmounts = validHours.map((hour) => hour.totalSnowAmount ?? 0);

  return {
    timestamps: validHours.map((hour) => hour.time),
    rates,
    amounts,
    probabilities,
    snowAmounts,
    totalAmount: amounts.reduce((sum, amount) => sum + amount, 0),
    peakRate: Math.max(...rates),
    averageProbability:
      probabilities.reduce((sum, prob) => sum + prob, 0) / probabilities.length,
  };
}
interface PrecipitationProbabilities {
  day: {
    precipitation?: number;
    rain?: number;
    heavyRain?: number;
    snow?: number;
    heavySnow?: number;
    hail?: number;
    sferics?: number;
  };
  night: {
    precipitation?: number;
    rain?: number;
    heavyRain?: number;
    snow?: number;
    heavySnow?: number;
    hail?: number;
    sferics?: number;
  };
}

function getPrecipitationProbabilities(
  day: DailyWeatherData
): PrecipitationProbabilities {
  return {
    day: {
      precipitation: day.dayProbabilityOfPrecipitation,
      rain: day.dayProbabilityOfRain,
      heavyRain: day.dayProbabilityOfHeavyRain,
      snow: day.dayProbabilityOfSnow,
      heavySnow: day.dayProbabilityOfHeavySnow,
      hail: day.dayProbabilityOfHail,
      sferics: day.dayProbabilityOfSferics,
    },
    night: {
      precipitation: day.nightProbabilityOfPrecipitation,
      rain: day.nightProbabilityOfRain,
      heavyRain: day.nightProbabilityOfHeavyRain,
      snow: day.nightProbabilityOfSnow,
      heavySnow: day.nightProbabilityOfHeavySnow,
      hail: day.nightProbabilityOfHail,
      sferics: day.nightProbabilityOfSferics,
    },
  };
}

// Export all types and utilities
export {
  // Hourly forecast types
  type MetOfficeHourlyForecastGeoJSON,
  type HourlyWeatherForecastFeature,
  type HourlyWeatherForecastProperties,
  type HourlyWeatherData,
  type TemperatureTrend,
  type PrecipitationForecast,

  // Daily forecast types
  type MetOfficeDailyForecastGeoJSON,
  type DailyWeatherForecastFeature,
  type DailyWeatherForecastProperties,
  type DailyWeatherData,
  type TemperatureRange,
  type PrecipitationProbabilities,

  // Shared types
  type ParameterMetadata,
  type ParameterUnit,
  type MetOfficeApiResponse,
  MetOfficeWeatherCode,

  // Hourly forecast utilities
  isMetOfficeHourlyForecastGeoJSON,
  getHourlyWeatherForTime,
  getCurrentHourlyWeather,
  getHourlyWeatherForDate,
  getAvailableHours,
  getHourlyTemperatureTrend,
  getHourlyPrecipitationForecast,

  // Daily forecast utilities
  isMetOfficeDailyForecastGeoJSON,
  getWeatherForDate,
  getCurrentWeather,
  getAvailableDates,
  getParameterMetadata,
  getTemperatureRange,
  getPrecipitationProbabilities,
};
